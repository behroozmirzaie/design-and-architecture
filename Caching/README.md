<!-- Output copied to clipboard! -->

<!-----

Yay, no errors, warnings, or alerts!

Conversion time: 0.474 seconds.


Using this Markdown file:

1. Paste this output into your source file.
2. See the notes and action items below regarding this conversion run.
3. Check the rendered output (headings, lists, code blocks, tables) for proper
   formatting and use a linkchecker before you publish this page.

Conversion notes:

* Docs to Markdown version 1.0β33
* Wed Feb 02 2022 07:50:10 GMT-0800 (PST)
* Source doc: Caching
----->


<p dir="rtl">
۱- Caching چیست؟ </p>


<p dir="rtl">
در computing،  کش یک لایه ذخیره سازی داده با سرعت بالا است که زیر مجموعه ای از داده ها را ذخیره می کند.معمولاً ماهیت گذرا دارد، به طوری که درخواست‌های آینده برای آن داده‌ها سریع‌تر از آنچه که با دسترسی به مکان ذخیره‌سازی اولیه داده ممکن است، ارائه می‌شوند.ذخیره سازی به شما امکان می دهد تا به طور موثر از داده های بازیابی یا محاسبه شده قبلی استفاده مجدد کنید.</p>


<p dir="rtl">
۲- آیا Redis فقط یک کش است؟</p>


<p dir="rtl">
مانند کش کردن Redis امکان میدهد:</p>




* in memory key-value storage

<p dir="rtl">
برخلاف کش کردن: </p>




* پشتیبانی از چند نوع datatype مانند strings,hashes,lists, sets, sorted sets, bimaps, ..
* قابلیتی را میده که داده های که قصد کش کردن داریم را در physcial storage ذخیره کنیم(اگر نیازبود)
* از مدل pub-sub پشتیبانی می کند
* حافظه نهان Redis برای دسترسی بالا امکان replication را فراهم می کند(master/slave)
* از اسکریپت های فوق سریع LUA پشتیبانی می کند. زمان اجرای آن برابر با اجرای دستورات C است.
* می تواند در چندین instance از برنامه به اشتراک گذاشته شود

<p dir="rtl">
۳- Resultset Caching چیست؟</p>


<p dir="rtl">
Resultset Caching نتایج یک پرس و جو پایگاه داده را به همراه پرس و جو در برنامه ذخیره می کند. هر بار که یک صفحه وب یک پرس و جو ایجاد می کند، برنامه‌ها بررسی می‌کنند که آیا نتایج قبلاً ذخیره شده‌اند یا نه، و اگر هستند، به جای آن، آنها را از مجموعه داده‌های درون حافظه بیرون می‌کشند. application هنوز باید صفحه را رندر کند.</p>


<p dir="rtl">
۴- عدم اعتبار کش چیست؟ (Cache Invalidation)</p>


<p dir="rtl">
There are only two hard things in Computer Science: cache invalidation and naming things.</p>


<p dir="rtl">
– Phil Karlton</p>


<p dir="rtl">
کش HTTP راه حلی برای بهبود عملکرد برنامه وب شما است. برای load کمتر بر روی برنامه و سریع ترین زمان پاسخ، می خواهید محتوا را برای مدت طولانی (TTL) در cache  ذخیره کنید. اما در عین حال، شما می خواهید که مشتریان شما به محض اینکه به روز رسانی شد، محتوای جدید  (<em>validate the freshness</em>) را مشاهده کنند.</p>


<p dir="rtl">
Cache invalidation بهترین حالت را به ما میده. هم میتونیم TTLs خیلی طولانی داشته باشیم و وقتی محتوا مقدار کمی تغییر کند میتونه از طریق cache ارائه کند. در همان زمان، زمانی که داده ها تغییر می کنند، آن تغییر بدون تاخیر در نمایش های وب منعکس می شود.</p>


<p dir="rtl">
۵- چه داده های معمولا باید cache شوند؟ </p>


<p dir="rtl">
گزینه های زیر فرآیند های خوبی برای cache کردن هستند: </p>




* پرس و جوهای طولانی مدت در پایگاه های داده
* درخواست های شبکه با تاخیر بالا(برای APIs خارجی)
* پردازش محاسبات های فشرده

<p dir="rtl">
۶- چند استراتژی برای نوشتن در  Cache را نام ببرید. </p>


<p dir="rtl">
دو روش معمول داره اینکار </p>


<p dir="rtl">
اول:  Pre-caching data، برای تکه های کوچک data، معمولا در زمان initalize شدن application هست و قبل از هرrequest ای </p>


<p dir="rtl">
دوم: On-demand، اول چک میکنه که داده در cache وجود دارد یا خیر(اگر data پیدا شد بهش cache hit میگن) اگر پیدا شد ازش استفاده می کند و باعث افزایش بهره وری برنامه می شود. و زمانی که داده در cache وجود نداشته باشد ( cache miss)، برنامه باید دوباره اطلاعات را از منبع آهسته بازیابی کنه و جواب را در cache ذخیره کند. بنابراین در زمان درخواست های بعدی برای همان data صرفه جویی می شود.</p>


<p dir="rtl">
۷- چند گزینه جایگزین برای Cache Invalidation چیست؟</p>


<p dir="rtl">
سه گزینه برای اینکار وجود دارد. </p>


<p dir="rtl">
اولین مورد این است که محتوای کش شده خود را با کاهش زمان زنده ماندن (TTL) به سرعت منقضی کنید. با این حال، TTL های کوتاه باعث load بیشتر بر روی برنامه می شوند زیرا محتوا باید fetched شود. علاوه بر این، کاهش TTL تضمین نمی کند که مشتریان محتوای تازه داشته باشند، به خصوص اگر محتوا به سرعت، در نتیجه تعامل مشتری با برنامه تغییر کند.</p>


<p dir="rtl">
گزینه دوم این است که در هر درخواستی، جدید بودن محتوای ذخیره شده را تأیید کنید، باز هم، این به معنای load  بیشتر روی برنامه شما است</p>


<p dir="rtl">
آخرین راه حل این است که به هیچ وجه محتوای volatile را در cache نگهداری نکنید. در حالی که این تضمین می کند که کاربر همیشه تغییرات را بدون تاخیر می بیند، بدیهی است که load برنامه شما را حتی بیشتر افزایش می دهد.</p>


<p dir="rtl">
۸-  برخی از متد های Cache Invalidation را نام ببرید. </p>


<p dir="rtl">
اول) Purge - محتوا را در cache سریعا پاک می کند. وقتی کاربر درخواست مجدد داده ها را داشته باشد، از طریق application ابتدا fetched می شود و در cache ذخیره می شود. این روش تمام انواع محتوای کش شده را حذف می کند.</p>


<p dir="rtl">
دوم) Refresh - محتوای درخواستی را از اپلیکیشن fetched می کند، حتی اگر محتوای کش موجود باشد. محتوایی که قبلاً در حافظه cache  شده بود با نسخه جدیدی از برنامه جایگزین می شود. این روش تنها یک نوع از محتوای cache را تحت تأثیر قرار می دهد.</p>


<p dir="rtl">
سوم) Ban - ارجاع به محتوای ذخیره شده به یک black list  (یا ban list) اضافه می شود. درخواست های client در مقابل این black list قرار می گیرد، و اگر درخواست match بشه، content جدید از برنامه fetched خواهد شد و به کاربر ارسال می شود و داده به cache اضافه می شود. این متد برعکس purge داده ها را سریع پاک نمی کند به جاش محتوای cache شده بعد از درخواست client به روز رسانی می شود. </p>

