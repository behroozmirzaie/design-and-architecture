<!-- Copy and paste the converted output. -->

<!-----

Yay, no errors, warnings, or alerts!

Conversion time: 0.602 seconds.


Using this Markdown file:

1. Paste this output into your source file.
2. See the notes and action items below regarding this conversion run.
3. Check the rendered output (headings, lists, code blocks, tables) for proper
   formatting and use a linkchecker before you publish this page.

Conversion notes:

* Docs to Markdown version 1.0β33
* Fri Feb 04 2022 00:32:47 GMT-0800 (PST)
* Source doc: Databases
----->


<p dir="rtl">
۱- نرمال سازی چیست؟ </p>


<p dir="rtl">
نرمال سازی در زمان طراحی پایگاه داده از داده های تکراری و اضافه جلوگیری می کند. اگر یک اطلاعات خاص در چند جا تکرار شده باشد این امکان وجود داره که یکی از اون جداول تغییر کند ولی سایر جدول ها آپدیت نشوند و این باعث بروز خطا خواهد شد. نرمال سازی از سطح فرم ۱ تا سطح فرم ۵ هستش. و هر کدام  از این فرم ها نحوه حل یک مشکل را تشریح می کند. </p>


<p dir="rtl">
وجود یک پایگاه داده ای که خطاهای نرمال سازی داشته باشد (normalization errors) ، خطر ورود داده های نامعتبر یا خراب به پایگاه داده را باز می کند. از آنجایی که داده‌ها «برای همیشه زنده هستند»، خلاص شدن از شر داده‌های مشکل دار  زمانی که برای اولین بار وارد پایگاه داده می‌شوند، دشوار است.</p>



---

<p dir="rtl">
۲- مزایای NoSQL نسبت به RDBMS سنتی چیست؟</p>


<p dir="rtl">
مزایای NoSQL نسبت به RDBMS ها عبارتند از:</p>




* از داده های نیمه ساختاریافته و داده های فرار پشتیبانی می کند
* اسکیما ندارد (schema)
* توان خواندن/نوشتن بسیار بالاست
* مقیاس پذیری افقی را می توان به راحتی به دست آورد (Horizontal scalability)
* از داده های بزرگ در حجم ترابایت و پتا بایت پشتیبانی می کند
* در داده های بزرگ ابزار از ابزار تحلیلی به خوبی پشتیبانی می کند.
* می توان در مکانیزم های  سخت افزاری ارزان تر استفاده کرد
* گزینه ذخیره سازی درون حافظه برای افزایش عملکرد پرس و جوها در دسترس است ( in memory caching)
* چرخه عمر توسعه سریعتر برای توسعه دهندگان (Faster development life cycles for developers)

<p dir="rtl">
مزایایی استفاده از RDBMS ها نسبت به NoSQL ها:</p>




* تراکنش ها با خصوصیات ACID و atomicity, consistency , isolation & durability
* پایبندی به Schema
* مدیریت query  در real time  (در صورتی که  اندازه داده ها کمتر از 10 ترا بایت باشد.)
* اجرای query های پیچیده شامل join و group by


---

<p dir="rtl">
۳- تفاوت DDL - Data Definition Language و DML -  Data manipulation Language چیست؟ </p>


<p dir="rtl">
DDL: دستوراتی هستند که برای تعریف پایگاه داده استفاده می شوند. CREATE، ALTER، DROP و TRUNCATE برخی از دستورات رایج DDL هستند.</p>


<p dir="rtl">
DML:  دستوراتی هستند که برای دستکاری داده ها استفاده می شوند. INSERT، UPDATE و DELETE برخی از دستورات رایج DML هستند.</p>



---

<p dir="rtl">
۴- خصوصیات ACID را توضیح دهید. </p>


<p dir="rtl">
اول) Atomicity: این قانون همه یا هیچ را برای تغییرات پایگاه داده تضمین می کند.(all-or-none)</p>


<p dir="rtl">
دوم) Consistency: مقادیر داده در سرتاسر پایگاه داده یکسان است.</p>


<p dir="rtl">
سوم) Isolation: گفته می شود که دو transactions مستقل از یکدیگر هستند.</p>


<p dir="rtl">
چهارم) Durability: داده ها حتی در زمان خرابی سرور از بین نمی روند.</p>



---

<p dir="rtl">
۵- منظور از Denormalization چیست؟ </p>


<p dir="rtl">
این فرآیند بهبود عملکرد پایگاه داده با افزودن داده های اضافی است.</p>



---

<p dir="rtl">
۶-  چگونه index کردن در پایگاه داده به بهبود عملکرد کمک می کند؟ </p>


<p dir="rtl">
هدف اصلی داشتن یک index,  افزایش سرعت جستجوها با کاهش تعداد رکوردها/ردیف‌ها در جدولی است که باید بررسی شود. index یک ساختار داده است (معمولاً یک درخت B) که مقادیر یک ستون خاص را در یک جدول ذخیره می کند.</p>



---

<p dir="rtl">
۷- تفاوت بین Primary key و Unique key را بفرمایید. </p>


<p dir="rtl">
Primary key: </p>


<p dir="rtl">
فقط یک primary key میتونه در جدول وجود داشته باشد. </p>


<p dir="rtl">
در برخی از DBMS ها نمیتواند Null باشد. </p>


<p dir="rtl">
کلید اصلی یک شناسه unique key یه رکورد است.</p>


<p dir="rtl">
کلید اصلی را می توان بر روی چندین ستون ایجاد کرد (کلید اولیه ترکیبی)</p>


<p dir="rtl">
Unique Key:</p>


<p dir="rtl">
در یک جدول می توانیم بیش از یک unique key داشته باشیم. </p>


<p dir="rtl">
میتواند مقدار null را هم داشته باشد. </p>


<p dir="rtl">
میتونه کلید candidate هم باشد. </p>


<p dir="rtl">
کلید منحصر به فرد می تواند NULL باشد. چندین ردیف می توانند مقادیر NULL داشته باشند و بنابراین ممکن است "یکتا" در نظر گرفته نشوند.</p>


<p dir="rtl">
تفاوت ها:</p>


<p dir="rtl">
الف) رفتار ( Behavior) - از کلید اصلی برای مشخص کردن یک record در جدول استفاده می شود، درحالیکه از unique key برای جلوگیری از تکرار مقادیر جلوگیری می شود. </p>


<p dir="rtl">
ب) indexing: موتور SQL به صورت پیش فرض برای primary key ها یک clustered index در صورتی که وجود نداشته باشند میسازه و برای unique key ها هم Non-Clustered index میسازه. </p>


<p dir="rtl">
پ) Nullability: کلید اصلی قابلیت Null گرفتن ندارد در صورتی که unique key میتواند Null بشود. </p>


<p dir="rtl">
ت) Existence: یک جدول حداکثر می تواند یک کلید اصلی داشته باشد، اما می تواند چندین کلید Unique داشته باشد. </p>


<p dir="rtl">
ج) Modifiability: شما نمی توانید مقادیر primary  را تغییر یا حذف کنید، اما مقادیرUnique key  می توانند.</p>



---

<p dir="rtl">
۸- تفاوت بین Clustered و Non Clustered ایندکس در چیست؟ </p>


<p dir="rtl">
با یک Clustered index، ردیف‌ها به صورت physically روی دیسک به همان ترتیب index ذخیره می‌شوند. بنابراین، تنها یک clustered index می تواند وجود داشته باشد. یک clustered index به این معنی است که شما به پایگاه داده می گویید مقادیر نزدیک را در واقع نزدیک به یکدیگر روی دیسک ذخیره کند.</p>


<p dir="rtl">
(store close values actually close to one another on the disk.)</p>


<p dir="rtl">
با یک  Non Clustered index ، فهرست دومی وجود دارد که pointers هایی  به ردیف‌های فیزیکی دارد. میتونیم non clustered inxed های زیادی داشته باشیم، اگرچه هر index جدید زمان لازم برای نوشتن رکوردهای جدید را افزایش می دهد.</p>


<p dir="rtl">
اگر می‌خواهید همه ستون‌ها را برگردانید، معمولاً خواندن از یک clustered index سریع‌تر است. لازم نیست ابتدا به index و سپس به جدول بروید.</p>


<p dir="rtl">
با استفاده از clustered index  نوشتن در جدول میتونه کند باشد، اگر نیاز به rearrange کردن data داشته باشیم. </p>



---

<p dir="rtl">
۹- چه زمانی از NoSQL ها استفاده می کنید؟ </p>


<p dir="rtl">
بستگی به یک سری نکته ها داره:</p>


<p dir="rtl">
الف) NoSQL زمان که داده های unstructured/schemaless داشته باشیم خوب هستش، معمولا نیازی به طراحی schema از قبل نداریم و میتونیم فیلد های جدید را بدون مراسم خاصی اضافه کنیم. </p>


<p dir="rtl">
ب) NoSQL معمولاً به دلیل عدم پشتیبانی از JOIN ها در دنیای RDBMS، بنابر این denormalised schema  را ترجیح می دهد. درنهایت  شما معمولاً نمایشی صاف و غیرعادی از داده های خود خواهید داشت.</p>


<p dir="rtl">
پ) معمولا scale out کردن NoSQL ها بسیار آسان است. افزودن node های  بیشتر برای تکثیر داده‌ها یکی از راه‌های ۱) ارائه مقیاس‌پذیری بیشتر و ۲) محافظت بیشتر در برابر از دست دادن داده‌ها در صورت از بین رفتن یک node  است. اما باز هم بستگی به نحوه پیکربندی و config کردن NoSQL DB دارد. </p>


<p dir="rtl">
ت) IMHO، پرس‌و‌جوها/complex/dynamic queries/reporting  به بهترین وجه از یک RDBMS ارائه می‌شوند. اغلب مواقع عملکرد پرس و جو برای یک NoSQL DB محدود است.</p>


<p dir="rtl">
ج) NoSQL DB ها اغلب فاقد توانایی انجام عملیات اتمی (atomic)  در چندین "جدول" هستند.</p>



---

<p dir="rtl">
۱۰- چه زمانی باید از NoSQL به جای rational database استفاده کنیم؟ </p>


<p dir="rtl">
همانطور که میدانیم Rational Database ها ACID را اجرا میکنند. بنابراین، شما فروشگاه های داده مبتنی برtransaction oriented  خواهید داشت. ثابت شده که برای ۹۹٪ از اپلیکیشن های دنیای واقعی مناسب است. با استفاده از rational database ها هر کاری میتونیم انجام بدیم. </p>


<p dir="rtl">
اما زمانی که راجع به scale کردن و سرعت در داده های زیاد صحبت میکنیم محدودیت هایی برای rational database ها بوجود میاد.  به عنوان مثال، گوگل و آمازون دارای داده های  حجیمی بیش از ترابایت در مراکز داده خود هستند. پرس و جو کردن  و یا insert کردن در این سناریو ها به دلیل ماهیت blocking/schema/transaction  انجام نمی شود. و به همین دلیل برای افزایش عملکرد و مقیاس پذیری عظیم  آنها پایگاه داده خودشون را پیاده سازی کردند( key-value stores).</p>


<p dir="rtl">
اگر شما به دیتابیس NoSQL نیاز داشته باشید معمولا خودتون از قبل متوجه میشید. مثلا: </p>


<p dir="rtl">
داده های شما هیچ منطقی با SQL ندارند، موقعی متوجه میشیم که برای دسترسی به هر داده ای باید کلی JOIN بزنیم. </p>


<p dir="rtl">
شما در حال شکستن مدل رابطه ای هستید، CLOB هایی دارید که داده های غیرعادی شده را ذخیره می کنند و شاخص های خارجی برای جستجوی آن داده ها تولید می کنید.</p>


<p dir="rtl">
مشتری 99.999% در دسترس بودن را در یک سایت پربازدید می خواهد.</p>



---

<p dir="rtl">
۱۱-  منظور از Optimistic locking چیست؟ </p>


<p dir="rtl">
قفل خوش‌بینانه استراتژی است که در آن یک رکورد را می‌خوانید، شماره نسخه را یادداشت می‌کنید و بررسی می‌کنید که نسخه قبل از write کردن تغییر نکرده باشد. وقتی رکورد را write  میکنید، به روز رسانی نسخه را فیلتر می کنید تا مطمئن شوید atomic  است. ( یعنی بین زمانی که رکورد را بررسی میکنید و رکورد را write میکنید به روز رسانی برای record ایجاد نشده باشد.) و ورژن را با یک hit آپدیت میکنید. </p>


<p dir="rtl">
اگر رکورد کثیف dirty  باشد (یعنی نسخه متفاوت با شما) transaction را لغو می‌کنید و کاربر می‌تواند آن را دوباره شروع کند.</p>


<p dir="rtl">
این استراتژی بیشتر برای سیستم‌های با حجم بالا و معماری‌های سه لایه که در آن‌ها لزوماً برای session خود به پایگاه داده ارتباط برقرار نمی‌کنید کاربرد دارد. در این شرایط، کلاینت نمی‌تواند قفل‌های پایگاه داده را حفظ کند، زیرا اتصالات ازpool  گرفته شده‌اند و ممکن است از یک اتصال به دسترسی دیگری استفاده نکنید.</p>



---

<p dir="rtl">
۱۲- چگونه B-trees index کار میکند؟ </p>


<p dir="rtl">
دلیل اصلی وجود B-Tree Indexes استفاده بهتر از رفتار دستگاه هایی است که تکه های بزرگ داده را می خوانند و می نویسند. برای اینکه B-Tree بهتر از درخت های باینری باشد، زمانی که داده ها باید بر روی دیسک ذخیره شوند، دو ویژگی حائز اهمیت هستند:</p>


<p dir="rtl">
الف) دسترسی به دیسک واقعا کند است. (در مقایسه با memory یا ن، دسترسی تصادفی به داده ها روی دیسک مرتباً کندتر است).</p>


<p dir="rtl">
ب) هر بار خواندن باعث می شود که یک بخش کامل از درایو load  شود. با فرض اینکه اندازه sector برابر با 4K باشد، به این معنی خواهد بود که 1000 intereges یا ده ها object بزرگ ذخیره کرده ایم. </p>


<p dir="rtl">
از این رو، می‌توانیم از جنبه‌های مثبت واقعیت دوم استفاده کنیم، در حالی که معایب را نیز به حداقل برسانیم - "یعنی تعداد دسترسی‌های دیسک."</p>


<p dir="rtl">
 \
بنابراین، به جای اینکه فقط یک عدد را در هر node ذخیره کنیم که به ما بگوید باید به سمت چپ یا راست ادامه دهیم، می توانیم یک index بزرگتر ایجاد کنیم که به ما بگوید که آیا باید به 1/100 اول ادامه دهیم یا دوم. یا به 99 ام. (کتاب‌ها را در کتابخانه‌ای تصور کنید که بر اساس حرف اول مرتب شده‌اند، سپس بر اساس حرف دوم و غیره). تا زمانی که همه این داده ها در یک sector قرار بگیرند، به هر حال load  می شوند، بنابراین ممکن است به طور کامل از آن استفاده کنیم.</p>


<p dir="rtl">
این منجر به جستجوهای تقریباً logb N  می شود، که در آن N تعداد رکوردها است.</p>



---

<p dir="rtl">
۱۳- هزینه اینکه database index داشته باشیم چیست؟ </p>


<p dir="rtl">
فضا را اشغال میکند. (It takes up space) و هر چی سایز جدول بزرگتر باشد index ما هم بزگتر می شود. یکی دیگر از موفقیت‌های عملکرد ایندکس‌ها این واقعیت است که هر زمان ردیف‌هایی را در جدول مربوطه اضافه، حذف یا به‌روزرسانی می‌کنید، همان عملیات باید روی index  شما انجام شود. به یاد داشته باشید که یک index باید حاوی همان داده های لحظه ای باشد که در ستون(های) جدولی که index پوشش می دهد، باشد.</p>


<p dir="rtl">
به عنوان یک قاعده کلی، ایندکس تنها در صورتی باید روی یک جدول ایجاد شود که داده های ستون index شده به طور مکرر پرس و جو شوند.</p>



---

<p dir="rtl">
۱۴- فرق بین Exclusive Lock و Update Lock را توضیح دهید. </p>


<p dir="rtl">
در موردExclusive Lock، هیچ قفل دیگری را نمی توان در آن ردیف یا جدول داشت. هر فرآیند process باید منتظر بماند تا فرآیندی که قفل را نگه می دارد آن را آزاد کند.</p>


<p dir="rtl">
در مورد قفلUpdate lock، هنگام خواندن ردیف یا رکورد، می‌توانید هر قفل دیگری را با آن ردیف یا رکورد مرتبط کنید. در صورت به روز رسانی رکورد، قفل به روز رسانی خود را به یک Exclusive Lock تغییر می دهد و تا زمانی که قفل آزاد نشود، هیچ فرآیند دیگری نمی تواند در آن ردیف قفل را بدست آورد.</p>



---

<p dir="rtl">
 </p>


<p dir="rtl">
۱۵- شاردینگ چیست؟ What Is Sharding؟</p>


<p dir="rtl">
Sharding یک رویکرد معماری است که یک سیستم پایگاه داده منطقی واحد را در مجموعه ای از ماشین ها توزیع می کند. Sharding یک <em>Horizontal partitioning</em> design scheme است. در این طراحی پایگاه داده، ردیف های جدول پایگاه داده به جای تقسیم به ستون ها، به طور جداگانه ذخیره می شوند. هر پارتیشن به عنوان یک قطعه (shard)  نامیده می شود، که می تواند به طور مستقل در یک سرور پایگاه داده یا مکان فیزیکی جداگانه قرار بگیرد.</p>


<p dir="rtl">
Sharding یک سیستم پایگاه داده را بسیار مقیاس پذیر می کند. تعداد کل ردیف ها در هر جدول در هر پایگاه داده کاهش می یابد زیرا جداول به چندین سرور تقسیم و توزیع می شوند. این کار  باعث کاهش اندازه index  می شود که به طور کلی به معنای بهبود عملکرد search است. رایج ترین روش برای ایجاد shard ها استفاده از هش کردن یک شناسه منحصر به فرد در برنامه است.(مثل user id) </p>


<p dir="rtl">
معایب شاردینگ:</p>


<p dir="rtl">
نیاز دارد که برنامه از محل داده ها مطلع باشد. </p>


<p dir="rtl">
هر گونه اضافه یا حذف گره از سیستم نیاز به تعادل مجدد در سیستم دارد.( Rebalance )</p>


<p dir="rtl">
اگر نیاز به join کردن بین node ها دارید اون موقع performance واقعا ضعیف میشود. بنابراین، دانستن نحوه استفاده از داده ها برای پرس و جو بسیار مهم می شود.</p>


<p dir="rtl">
اگر منطق shard را اشتباه پیاده سازی کنیم همه چیز خیلی خیلی بدتر خواهد شد. </p>



---

<p dir="rtl">
۱۶-  برخی از معاب Hash index را نام ببرید. </p>


<p dir="rtl">
جداول Hash ساختارهای داده مرتب شده ای نیستند، و انواع مختلفی از پرس و جوها وجود دارد که hash index  حتی نمی توانند به آنها کمک کنند.</p>


<p dir="rtl">
به عنوان مثال، فرض کنید می خواهید همه کارمندانی که کمتر از 40 سال سن دارند را بیابید. چگونه می توانید این کار را با hash index  انجام دهید؟ خب، این امکان پذیر نیست زیرا جدول هش فقط برای جستجوی جفت های کلید-مقدار key-value خوب است. برای queryهایی که برابری را بررسی میکنند خوب است. </p>



---
